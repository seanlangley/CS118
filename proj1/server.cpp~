/* A simple server in the internet domain using TCP
   The port number is passed as an argument
   This version runs forever, forking off a separate
   process for each connection
*/
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <iostream>
#include <signal.h>  /* signal name macros, and the kill() prototype */
#include <vector>
#include <fstream>

#include "server.h"
using namespace std;


void error(string msg)
{
  cout << "CALLED ERROR";
  const char *c_msg = msg.c_str();
  perror(c_msg);
  exit(1);
}


int get_file(char *send, char *file_name)
{
  char *buffer = NULL;
  int length = 0;
  ifstream is (file_name, ifstream::binary);
  if (is) {
    // get length of file:
    is.seekg (0, is.end);
    length = is.tellg();
    is.seekg (0, is.beg);

    buffer = new char [length];

    // read data as a block:
    is.read (buffer,length);    
    if(!is)
      error("Error reading File.");
    is.close();
  
  }

  if(buffer != NULL)
    strcpy(send, buffer);
  else
    send[0] = '\0';

  return length;

}


void parse_requests(char *file_name, char *file_ext, char *buffer)
{
  char *buffer_copy = new char[4096];
  char *buffer_copy2 = new char[4096];
  strcpy(buffer_copy, buffer);
  strcpy(buffer_copy2, buffer);
  
  char *name = strtok(buffer_copy, "/");  
  name = strtok(NULL, " ");
  strcpy(file_name, name);
  
  char *type = strtok(buffer_copy2, "/");
  type = strtok(NULL, ".");
  type = strtok(NULL, " ");
  //Instead of html, add text/html
  //  requests->push_back(file_type);

  if(strcmp(type, "html") == 0)
    strcpy(file_ext, "text/html");
  else if(strcmp(type, "jpg") == 0)
    strcpy(file_ext, "image/jpg");
  //  else if(strcmp(
  delete[] buffer_copy;
  delete[] buffer_copy2;

}



int main(int argc, char *argv[])
{
    int sockfd, newsockfd, portno;
    socklen_t clilen;
    struct sockaddr_in serv_addr, cli_addr;

    if (argc < 2) {
        fprintf(stderr, "ERROR, no port provided\n");
        exit(1);
    }

    sockfd = socket(AF_INET, SOCK_STREAM, 0);  // create socket
    if (sockfd < 0)
        error("ERROR opening socket");
    memset((char *) &serv_addr, 0, sizeof(serv_addr));  // reset memory

    // fill in address info
    portno = atoi(argv[1]);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(portno);

    if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0)
        error("ERROR on binding");

    listen(sockfd, 5);  // 5 simultaneous connection at most

    //accept connections
    newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);

    if (newsockfd < 0)
     error("ERROR on accept");

    int n;
    char buffer[16000];

    memset(buffer, 0, 16000);  // reset memory
    
    //read client's message
    n = read(newsockfd, buffer, 16000);
    if (n < 0) error("ERROR reading from socket");
    printf("%s\n", buffer);
    


    //Only need file name and extension
    char file_name[64];
    char file_ext[64];
    parse_requests(file_name, file_ext, buffer);


    char file[5102];
    int file_length = get_file(file, file_name);
    if(file[0] == '\0')
      error("Error getting file.");
    string content_length_str = to_string(file_length);
    const char *content_length = content_length_str.c_str();
    

    //reply to client  
    vector<string> responses;
    responses.push_back("HTTP/1.1 200 OK\r\n");
    responses.push_back("Content-Type: text/html\r\n");
    responses.push_back("Content-Length: ");
    responses.push_back(content_length_str);
    responses.push_back("\r\n\r\n");
            

    for(unsigned long i = 0; i < responses.size(); i++)
      {
	cout << responses[i];

	n = send(newsockfd, responses[i].c_str(), responses[i].size(), 0);	
	if(n < 0) error("abcd");
      }

    cout << file << endl;
    n = send(newsockfd, file, file_length, 0);
    if(n < 0) error("ERROR writing to socket");    
    cout << n << endl;

    close(newsockfd);  // close connection
    close(sockfd);

    return 0;

}
